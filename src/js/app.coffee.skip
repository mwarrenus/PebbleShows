(function() {
  var ADVANCED_MENU, CONFIG_BASE_URL, Emitter, ICON_MENU_CALENDAR, ICON_MENU_CHECKED, ICON_MENU_EYE, ICON_MENU_HOME, ICON_MENU_UNCHECKED, Settings, UI, ajax, async, compareByFunction, compareByKey, createToWatchMenuItem, displayShowsMenu, displaySignInWindow, displayToWatchMenu, displayUpcomingMenu, firstUnwatchedEpisode, getOrFetchEpisodeData, getToWatchList, initSettings, isNextEpisodeForItemAired, mainMenu, modifyCheckState, refreshModels, reloadShow, shows, signInWindow, sleep, traktvRequest, updatesEmitter, userDateFormat;

  UI = require('ui');

  Settings = require('settings');

  ajax = require('ajax');

  async = require('async');

  Emitter = require('emitter');

  CONFIG_BASE_URL = 'http://bobby.alessiobogon.com:8020/';

  ICON_MENU_UNCHECKED = 'images/icon_menu_unchecked.png';

  ICON_MENU_CHECKED = 'images/icon_menu_checked.png';

  ICON_MENU_CALENDAR = 'images/icon_calendar.png';

  ICON_MENU_EYE = 'images/icon_eye.png';

  ICON_MENU_HOME = 'images/icon_home.png';

  userDateFormat = "D MMMM YYYY";

  console.log("accessToken: " + (Settings.option('accessToken')));

  updatesEmitter = new Emitter();

  signInWindow = void 0;

  shows = void 0;

  sleep = function(ms) {
    var unixtime_ms, _results;
    unixtime_ms = new Date().getTime();
    _results = [];
    while (new Date().getTime() < unixtime_ms + ms) {
      _results.push(1);
    }
    return _results;
  };

  traktvRequest = function(opt, success, failure) {
    var accessToken;
    console.log("traktvRequest: opt: " + (JSON.stringify(opt)));
    if (typeof opt === 'string') {
      opt = opt.indexOf('http') === 0 ? {
        url: opt
      } : {
        action: opt
      };
    }
    if (opt.method == null) {
      opt.method = 'GET';
    }
    if (opt.action[0] === '/') {
      opt.action = opt.action.slice(1);
    }
    if (opt.url == null) {
      opt.url = "https://api-v2launch.trakt.tv/" + opt.action;
    }
    accessToken = Settings.option('accessToken');
    if (accessToken == null) {
      displaySignInWindow();
      if (failure != null) {
        failure("accessToken is needed");
      }
      return;
    }
    return ajax({
      url: opt.url,
      type: 'json',
      headers: {
        'trakt-api-version': 2,
        'trakt-api-key': '16fc8c04f10ebdf6074611891c7ce2727b4fcae3d2ab2df177625989543085e9',
        Authorization: "Bearer " + accessToken
      },
      method: opt.method,
      data: opt.data
    }, success, function(response, status, req) {
      if (status === 401) {
        console.log("Server says that authorization is required");
        displaySignInWindow();
      }
      console.log("Request failure (" + status + " " + opt.method + " " + opt.url + ")");
      if (failure != null) {
        return failure(response, status, req);
      }
    });
  };

  reloadShow = function(showID, success, failure) {
    return traktvRequest("/shows/" + showID + "/progress/watched", function(response, status, req) {
      var i, item, _i, _len;
      console.log("Reloading show " + showID);
      for (_i = 0, _len = shows.length; _i < _len; _i++) {
        i = shows[_i];
        if (i.show.ids.trakt === showID) {
          item = i;
        }
      }
      item.next_episode = response.next_episode;
      item.seasons = response.seasons;
      if (success != null) {
        return success(item);
      }
    }, failure != null ? failure : void 0);
  };

  getToWatchList = function(showList, callback) {
    var showListUpdated;
    showListUpdated = showList.slice(0);
    return async.each(showListUpdated, function(item, doneItem) {
      return traktvRequest("/shows/" + item.show.ids.trakt + "/progress/watched", function(response, status, req) {
        item.next_episode = response.next_episode;
        item.seasons = response.seasons;
        return doneItem();
      }, function(response, status, req) {
        return doneItem();
      });
    }, function(err) {
      if (callback != null) {
        return callback(showListUpdated);
      }
    });
  };

  displaySignInWindow = function() {
    signInWindow = new UI.Card({
      title: 'Sign-in required',
      body: 'Open the Pebble App and configure Pebble Shows.'
    });
    signInWindow.on('click', 'back', function() {});
    return signInWindow.show();
  };

  isNextEpisodeForItemAired = function(item) {
    var s, season, _i, _len, _ref;
    if (item.next_episode == null) {
      return false;
    }
    if (item.next_episode.season > item.seasons.length) {
      return false;
    }
    _ref = item.seasons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      if (s.number === item.next_episode.season) {
        season = s;
      }
    }
    if (item.next_episode.number > season.aired) {
      return false;
    }
    return true;
  };

  refreshModels = function() {
    return traktvRequest('sync/watched/shows', function(response, status, req) {
      return getToWatchList(response, function(toWatchList) {
        console.log('toWatchList updated');
        shows = toWatchList;
        return updatesEmitter.emit('update', 'shows', shows);
      });
    });
  };

  modifyCheckState = function(opt, success, failure) {
    var action, request;
    console.log("checkWatched: opt: " + (JSON.stringify(opt)));
    if ((opt.episodeNumber != null) && (opt.seasonNumber == null)) {
      failure();
      return;
    }
    if (opt.completed == null) {
      opt.completed = true;
    }
    request = {
      shows: [
        opt.seasonNumber ? {
          ids: {
            trakt: opt.showID
          },
          seasons: [
            {
              number: opt.seasonNumber,
              episodes: opt.episodeNumber ? [
                {
                  number: opt.episodeNumber
                }
              ] : void 0
            }
          ]
        } : void 0
      ]
    };
    action = '/sync/history';
    if (opt.completed === false) {
      action += '/remove';
    }
    return traktvRequest({
      action: action,
      method: 'POST',
      data: request
    }, function(response, status, req) {
      var episode, item, season, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      console.log("Check succeeded: " + (JSON.stringify(request)));
      for (_i = 0, _len = shows.length; _i < _len; _i++) {
        item = shows[_i];
        if (item.show.ids.trakt === opt.showID) {
          _ref = item.seasons;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            season = _ref[_j];
            if ((opt.seasonNumber == null) || season.number === opt.seasonNumber) {
              _ref1 = season.episodes;
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                episode = _ref1[_k];
                if (!((opt.episodeNumber == null) || episode.number === opt.episodeNumber)) {
                  continue;
                }
                console.log("Marking as seen " + item.show.title + " S" + season.number + "E" + episode.number);
                episode.completed = opt.completed;
              }
            }
          }
        }
      }
      return success();
    }, function(response, status, req) {
      console.log("Check FAILURE");
      return failure(response, status, req);
    });
  };

  compareByKey = function(key) {
    return function(a, b) {
      if (a[key] < b[key]) {
        -1;
      }
      if (a[key] === b[key]) {
        0;
      }
      if (a[key] > b[key]) {
        return 1;
      }
    };
  };

  compareByFunction = function(keyFunction) {
    return function(a, b) {
      if (keyFunction(a) < keyFunction(b)) {
        -1;
      }
      if (keyFunction(a) === keyFunction(b)) {
        0;
      }
      if (keyFunction(a) > keyFunction(b)) {
        return 1;
      }
    };
  };

  firstUnwatchedEpisode = function(show) {
    var episode, episodes, season, seasons, _i, _j, _len, _len1;
    seasons = show.seasons.slice(0);
    seasons.sort(compareByKey('number'));
    for (_i = 0, _len = seasons.length; _i < _len; _i++) {
      season = seasons[_i];
      episodes = season.episodes.slice(0);
      episodes.sort(compareByKey('number'));
      for (_j = 0, _len1 = episodes.length; _j < _len1; _j++) {
        episode = episodes[_j];
        if (episode.completed !== true) {
          return {
            episodeNumber: episode.number,
            seasonNumber: season.number
          };
        }
      }
    }
  };

  createToWatchMenuItem = function(opt) {
    var key, _i, _len, _ref;
    _ref = ['showID', 'episodeTitle', 'seasonNumber', 'episodeNumber', 'completed'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (opt[key] == null) {
        console.log("ERROR: " + key + " not in " + (JSON.stringify(opt)));
        return;
      }
    }
    return {
      title: opt.episodeTitle,
      subtitle: "Season " + opt.seasonNumber + " Ep. " + opt.episodeNumber,
      icon: opt.completed ? ICON_MENU_CHECKED : ICON_MENU_UNCHECKED,
      data: {
        showID: opt.showID,
        episodeNumber: opt.episodeNumber,
        seasonNumber: opt.seasonNumber,
        completed: opt.completed,
        isNextEpisodeListed: opt.isNextEpisodeListed
      }
    };
  };

  getOrFetchEpisodeData = function(showID, seasonNumber, episodeNumber, callback) {
    var e, episode, fetchEpisodeIDAndTitle, getOrFetchOverview, i, item, s, season, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    console.log("getOrFetchEpisodeData for " + showID + ", " + seasonNumber + ", " + episodeNumber);
    for (_i = 0, _len = shows.length; _i < _len; _i++) {
      i = shows[_i];
      if (i.show.ids.trakt === showID) {
        item = i;
      }
    }
    _ref = item.seasons;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      s = _ref[_j];
      if (s.number === seasonNumber) {
        season = s;
      }
    }
    if (season == null) {
      season = {
        number: seasonNumber,
        aired: 0,
        completed: 0,
        episodes: []
      };
    }
    _ref1 = season.episodes;
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      e = _ref1[_k];
      if (e.number === episodeNumber) {
        episode = e;
      }
    }
    if (episode == null) {
      episode = {
        number: episodeNumber,
        completed: false
      };
      season.episodes.push(episode);
    }
    console.log("Considering episode: " + (JSON.stringify(episode)));
    episode.seasonNumber = seasonNumber;
    episode.episodeNumber = episodeNumber;
    episode.showID = showID;
    episode.showTitle = item.show.title;
    getOrFetchOverview = function(success) {
      if (episode.overview != null) {
        console.log("Overview already available");
        success(episode);
        return;
      }
      console.log("fetching overview...");
      return traktvRequest("/search?id_type=trakt-episode&id=" + episode.episodeID, function(response, status, req) {
        console.log("Fetched overview: " + response);
        if (response) {
          episode.overview = response[0].episode.overview;
        }
        if (success != null) {
          return success(episode);
        }
      });
    };
    fetchEpisodeIDAndTitle = function(showID, seasonNumber, episodeNumber, successFetchEpisodeIDAndTitle) {
      return traktvRequest("/shows/" + showID + "/seasons/" + seasonNumber + "/episodes/" + episodeNumber, function(response, status, req) {
        console.log("fetchEpisodeIDAndTitle response: " + response);
        episode.episodeID = response.ids.trakt;
        episode.episodeTitle = response.title;
        if (successFetchEpisodeIDAndTitle != null) {
          return successFetchEpisodeIDAndTitle(episode);
        }
      });
    };
    if ((episode.episodeID != null) && (episode.episodeTitle != null)) {
      console.log("going to fetch overview");
      return getOrFetchOverview(callback);
    } else {
      console.log("going to fetch ep id and title");
      return fetchEpisodeIDAndTitle(showID, seasonNumber, episodeNumber, function(episode) {
        console.log("fetched id and title: " + (JSON.stringify(episode)));
        return getOrFetchOverview(callback);
      });
    }
  };

  displayToWatchMenu = function(callback) {
    var getToWatchMenuItems, handler, item, toWatchMenu;
    if (shows == null) {
      handler = function(e) {
        updatesEmitter.off('updates', 'shows', handler);
        return displayToWatchMenu(callback);
      };
      updatesEmitter.on('update', 'shows', handler);
      return;
    }
    getToWatchMenuItems = function() {
      var ep, ep_s, item, toWatch, _i, _len;
      toWatch = [];
      for (_i = 0, _len = shows.length; _i < _len; _i++) {
        item = shows[_i];
        ep = firstUnwatchedEpisode(item);
        ep_s = ep != null ? "S" + ep.seasonNumber + "E" + ep.episodeNumber : "undefined";
        console.log("First unwatched episode for " + item.show.title + " is " + ep_s);
        if (ep != null) {
          toWatch.push({
            title: item.show.title,
            subtitle: "Season " + ep.seasonNumber + " Ep. " + ep.episodeNumber,
            icon: ICON_MENU_UNCHECKED,
            data: {
              episodeNumber: ep.episodeNumber,
              seasonNumber: ep.seasonNumber,
              showID: item.show.ids.trakt,
              completed: false
            }
          });
        }
      }
      return toWatch;
    };
    toWatchMenu = new UI.Menu({
      sections: (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = shows.length; _i < _len; _i++) {
          item = shows[_i];
          if (isNextEpisodeForItemAired(item)) {
            _results.push({
              title: item.show.title,
              items: [
                createToWatchMenuItem({
                  showID: item.show.ids.trakt,
                  episodeTitle: item.next_episode.title,
                  seasonNumber: item.next_episode.season,
                  episodeNumber: item.next_episode.number,
                  completed: false
                })
              ]
            });
          }
        }
        return _results;
      })()
    });
    toWatchMenu.on('longSelect', function(e) {
      var data, element;
      element = e.item;
      data = e.item.data;
      data.previousSubtitle = element.subtitle;
      element.subtitle = element.data.completed ? "Unchecking..." : "Checking...";
      toWatchMenu.item(e.sectionIndex, e.itemIndex, element);
      return modifyCheckState({
        showID: data.showID,
        episodeNumber: data.episodeNumber,
        seasonNumber: data.seasonNumber,
        completed: !e.item.completed
      }, function() {
        var isNowCompleted;
        element = e.item;
        isNowCompleted = !element.data.completed;
        if (isNowCompleted) {
          element.data.completed = true;
          element.icon = ICON_MENU_CHECKED;
        } else {
          element.data.completed = false;
          element.icon = ICON_MENU_UNCHECKED;
        }
        element.subtitle = element.data.previousSubtitle;
        delete element.data.previousSubtitle;
        toWatchMenu.item(e.sectionIndex, e.itemIndex, element);
        if (isNowCompleted && !element.isNextEpisodeListed) {
          return reloadShow(data.showID, function(reloadedShow) {
            var newItem;
            console.log("RELOADED ShowID: " + reloadedShow.show.ids.trakt + ", title: " + reloadedShow.show.title);
            if (isNextEpisodeForItemAired(reloadedShow) && !element.isNextEpisodeListed) {
              element.isNextEpisodeListed = true;
              newItem = createToWatchMenuItem({
                showID: data.showID,
                episodeTitle: reloadedShow.next_episode.title,
                seasonNumber: reloadedShow.next_episode.season,
                episodeNumber: reloadedShow.next_episode.number,
                completed: false
              });
              console.log("toWatchMenu.item(" + e.sectionIndex + ", " + e.section.items.length + ", " + (JSON.stringify(newItem)));
              return toWatchMenu.item(e.sectionIndex, e.section.items.length, newItem);
            }
          });
        }
      });
    });
    toWatchMenu.on('select', function(e) {
      var data, element;
      element = e.item;
      data = element.data;
      return getOrFetchEpisodeData(data.showID, data.seasonNumber, data.episodeNumber, function(episode) {
        var detailedItemCard;
        detailedItemCard = new UI.Card({
          title: episode.showTitle,
          subtitle: "Season " + episode.seasonNumber + " Ep. " + episode.episodeNumber,
          body: "Title: " + episode.episodeTitle + "\nOverview: " + episode.overview,
          style: 'small',
          scrollable: true
        });
        return detailedItemCard.show();
      });
    });
    toWatchMenu.show();
    if (callback != null) {
      return callback();
    }
  };

  displayUpcomingMenu = function(callback) {
    var days, startingDate;
    startingDate = moment().format('YYYY-MM-DD');
    days = 7;
    return traktvRequest("/calendars/shows/" + startingDate + "/" + days, function(response, status, req) {
      var date, item, items, sections, upcomingMenu;
      sections = (function() {
        var _results;
        _results = [];
        for (date in response) {
          items = response[date];
          _results.push({
            title: moment(date).format(userDateFormat),
            items: (function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                if (moment(item.airs_at) >= moment()) {
                  _results1.push({
                    title: item.show.title,
                    subtitle: "S" + item.episode.season + "E" + item.episode.number + " | " + (moment(item.airs_at).format('HH:MM')),
                    data: {
                      showID: item.show.ids.trakt,
                      seasonNumber: item.episode.season,
                      episodeNumber: item.episode.number
                    }
                  });
                }
              }
              return _results1;
            })()
          });
        }
        return _results;
      })();
      upcomingMenu = new UI.Menu({
        sections: sections
      });
      upcomingMenu.show();
      upcomingMenu.on('select', function(e) {
        var data, element;
        element = e.item;
        data = element.data;
        return getOrFetchEpisodeData(data.showID, data.seasonNumber, data.episodeNumber, function(episode) {
          var detailedItemCard;
          console.log("response for " + data.showID + ", " + data.seasonNumber + ", " + data.episodeNumber);
          console.log("--> " + (JSON.stringify(episode)));
          detailedItemCard = new UI.Card({
            title: episode.showTitle,
            subtitle: "Season " + episode.seasonNumber + " Ep. " + episode.episodeNumber,
            body: "Title: " + episode.episodeTitle + "\nOverview: " + episode.overview,
            style: 'small',
            scrollable: true
          });
          return detailedItemCard.show();
        });
      });
      if (callback != null) {
        return callback();
      }
    });
  };

  displayShowsMenu = function(callback) {
    var handler, item, showsMenu, sortedShows;
    console.log("displayShowsMenu: shows? " + (shows != null));
    if (shows == null) {
      handler = function(e) {
        updatesEmitter.off('updates', 'shows', handler);
        return displayShowsMenu(callback);
      };
      updatesEmitter.on('update', 'shows', handler);
      return;
    }
    sortedShows = shows.slice(0);
    sortedShows.sort(compareByFunction(function(e) {
      return moment(e.last_watched_at);
    }));
    showsMenu = new UI.Menu({
      sections: [
        {
          items: (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = sortedShows.length; _i < _len; _i++) {
              item = sortedShows[_i];
              _results.push({
                title: item.show.title,
                data: {
                  showID: item.show.ids.trakt
                }
              });
            }
            return _results;
          })()
        }
      ]
    });
    showsMenu.show();
    return showsMenu.on('select', function(e) {
      var data, i, season, seasonsMenu, _i, _len;
      data = e.item.data;
      for (_i = 0, _len = shows.length; _i < _len; _i++) {
        i = shows[_i];
        if (i.show.ids.trakt === data.showID) {
          item = i;
        }
      }
      seasonsMenu = new UI.Menu({
        sections: [
          {
            items: (function() {
              var _j, _len1, _ref, _results;
              _ref = item.seasons;
              _results = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                season = _ref[_j];
                _results.push({
                  title: "Season " + season.number,
                  data: {
                    showID: data.showID,
                    seasonNumber: season.number
                  }
                });
              }
              return _results;
            })()
          }
        ]
      });
      seasonsMenu.show();
      return seasonsMenu.on('select', function(e) {
        var s, _j, _len1, _ref;
        data = e.item.data;
        _ref = item.seasons;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          s = _ref[_j];
          if (s.number === data.seasonNumber) {
            season = s;
          }
        }
        return async.map(season.episodes, function(ep, callbackResult) {
          return getOrFetchEpisodeData(data.showID, data.seasonNumber, ep.number, function(episode) {
            return callbackResult(null, episode);
          });
        }, function(err, episodes) {
          var episode, episodesMenu;
          console.log("------results of map: err " + err + " --------------");
          if (err != null) {
            console.log("------results of map: err " + err + " --------------");
            return;
          }
          console.log("------results of map: 1st: " + (JSON.stringify(episodes[0])));
          episodesMenu = new UI.Menu({
            sections: [
              {
                items: (function() {
                  var _k, _len2, _results;
                  _results = [];
                  for (_k = 0, _len2 = episodes.length; _k < _len2; _k++) {
                    episode = episodes[_k];
                    _results.push({
                      title: episode.episodeTitle,
                      subtitle: "Season " + episode.seasonNumber + " Ep. " + episode.episodeNumber,
                      data: {
                        episodeTitle: episode.episodeTitle,
                        overview: episode.overview,
                        seasonNumber: episode.seasonNumber,
                        episodeNumber: episode.episodeNumber,
                        showID: episode.showID,
                        showTitle: episode.showTitle
                      }
                    });
                  }
                  return _results;
                })()
              }
            ]
          });
          episodesMenu.show();
          episodesMenu.on('select', function(e) {
            var detailedItemCard;
            data = e.item.data;
            detailedItemCard = new UI.Card({
              title: data.showTitle,
              subtitle: "Season " + data.seasonNumber + " Ep. " + data.episodeNumber,
              body: "Title: " + data.episodeTitle + "\nOverview: " + data.overview,
              style: 'small',
              scrollable: true
            });
            return detailedItemCard.show();
          });
          if (callback != null) {
            return callback();
          }
        });
      });
    });
  };

  initSettings = function() {
    Settings.init();
    return Settings.config({
      url: "" + CONFIG_BASE_URL + "login",
      autoSave: true
    }, function(e) {
      console.log("Returned from settings");
      signInWindow.hide();
      return refreshModels();
    });
  };

  initSettings();

  ADVANCED_MENU = false;

  mainMenu = new UI.Menu({
    sections: [
      {
        items: [
          {
            title: 'To watch',
            icon: ICON_MENU_EYE,
            id: 'toWatch'
          }, {
            title: 'Upcoming',
            icon: ICON_MENU_CALENDAR,
            id: 'upcoming'
          }, {
            title: 'My shows',
            icon: ICON_MENU_HOME,
            id: 'myShows'
          }
        ]
      }
    ]
  });

  if (ADVANCED_MENU) {
    mainMenu.state.sections[0].items.push({
      title: 'Advanced',
      id: 'advanced'
    });
  }

  mainMenu.show();

  mainMenu.on('select', function(e) {
    var advancedMenu, displayFunction;
    switch (e.item.id) {
      case 'toWatch':
      case 'upcoming':
        e.item.subtitle = "Loading...";
        mainMenu.item(e.sectionIndex, e.itemIndex, e.item);
        displayFunction = (function() {
          switch (e.item.id) {
            case 'toWatch':
              return displayToWatchMenu;
            case 'upcoming':
              return displayUpcomingMenu;
          }
        })();
        return displayFunction(function() {
          delete e.item.subtitle;
          return mainMenu.item(e.sectionIndex, e.itemIndex, e.item);
        });
      case 'myShows':
        return displayShowsMenu();
      case 'advanced':
        advancedMenu = new UI.Menu({
          sections: [
            {
              items: [
                {
                  title: 'Reset localStorage',
                  action: function() {
                    localStorage.clear();
                    initSettings();
                    return console.log("Local storage cleared");
                  }
                }, {
                  title: 'Refresh',
                  action: function() {
                    return refreshModels();
                  }
                }
              ]
            }
          ]
        });
        advancedMenu.on('select', function(e) {
          return e.item.action();
        });
        return advancedMenu.show();
    }
  });

  refreshModels();

}).call(this);
